<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lernpuzzle Memory Builder</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel für JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- MathJax für LaTeX Formeln -->
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' },
      startup: { typeset: false }
    };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        @keyframes bounce-in {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }
        .animate-bounce-in { animation: bounce-in 0.6s cubic-bezier(0.215, 0.610, 0.355, 1.000) both; }
        
        .perspective-1000 { perspective: 1000px; }
        .transform-style-3d { transform-style: preserve-3d; }
        .backface-hidden { backface-visibility: hidden; }
        .rotate-y-180 { transform: rotateY(180deg); }
        
        /* MathJax Anpassung: Verhindert Fokus-Rahmen */
        mjx-container { outline: none !important; font-size: inherit !important; }
    </style>
</head>
<body class="bg-slate-100 text-slate-900 font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- ICONS ---
        const Icon = ({ path, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                {path}
            </svg>
        );

        const Icons = {
            Trash2: (p) => <Icon {...p} path={<><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></>} />,
            Plus: (p) => <Icon {...p} path={<><path d="M5 12h14"/><path d="M12 5v14"/></>} />,
            Play: (p) => <Icon {...p} path={<polygon points="5 3 19 12 5 21 5 3"/>} />,
            Download: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></>} />,
            Settings: (p) => <Icon {...p} path={<><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></>} />,
            Upload: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></>} />,
            Eye: (p) => <Icon {...p} path={<><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></>} />,
            Lock: (p) => <Icon {...p} path={<><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></>} />,
            FileJson: (p) => <Icon {...p} path={<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M10 13a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1"/></>} />,
            Shuffle: (p) => <Icon {...p} path={<><path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l14.2-13h3.1"/><path d="M2 5h1.6c1.3 0 2.5.6 3.3 1.7l1.6 1.5"/><path d="M12 15.5l2.7 2.5c.8 1.1 2 1.7 3.3 1.7h3.1"/></>} />,
            FlipHorizontal: (p) => <Icon {...p} path={<><path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3"/><path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/><path d="M12 3v18"/></>} />,
            Type: (p) => <Icon {...p} path={<><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" x2="15" y1="20" y2="20"/><line x1="12" x2="12" y1="4" y2="20"/></>} />,
            Trophy: (p) => <Icon {...p} path={<><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></>} />,
            X: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></>} />
        };

        const DEFAULT_PAIRS = [
            { id: 1, a: "Verschiebung um 3 nach <br><b>rechts</b>", b: "\\( f(x) = (x-3)^2 \\)" },
            { id: 2, a: "\\( f(x) = 3(x+2)^2 - 5 \\)", b: "SP(-2 / -5)" },
            { id: 3, a: "\\( f(x) = x^2 \\)", b: "Normalparabel" },
            { id: 4, a: "\\( f(x) = (x-3)(x+3) \\)", b: "Nullstellen: 3 und -3" },
            { id: 5, a: "\\( f(x) = x^2 + 2 \\)", b: "Verschiebung um 2 nach oben" },
            { id: 6, a: "\\( \\sin(0) \\)", b: "0" }
        ];

        function MemoryBuilderApp() {
            const [phase, setPhase] = useState('editor');
            const [pairs, setPairs] = useState(DEFAULT_PAIRS);
            const [jsonInput, setJsonInput] = useState("");
            const [showJsonModal, setShowJsonModal] = useState(false);
            const [displayMode, setDisplayMode] = useState('normal');
            const [p1Secret, setP1Secret] = useState("");
            const [p1Confirm, setP1Confirm] = useState("");
            const [p2Secret, setP2Secret] = useState("");
            const [p2Confirm, setP2Confirm] = useState("");
            const [cards, setCards] = useState([]);
            const [flippedIndices, setFlippedIndices] = useState([]);
            const [matchedIndices, setMatchedIndices] = useState([]);
            const [turn, setTurn] = useState(1);
            const [scores, setScores] = useState({ 1: 0, 2: 0 });
            const [gameMessage, setGameMessage] = useState("");
            const [showGuessInput, setShowGuessInput] = useState(false);
            const [guessAttempt, setGuessAttempt] = useState("");
            const [winner, setWinner] = useState(null);
            const [canGuess, setCanGuess] = useState(false);
            const [winReason, setWinReason] = useState("");
            const [waitingForTurnEnd, setWaitingForTurnEnd] = useState(false);
            const guessTimerRef = useRef(null);

            useEffect(() => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    setTimeout(() => {
                        window.MathJax.typesetPromise().catch((err) => console.log('MathJax error:', err));
                    }, 50);
                }
            }, [phase, cards, pairs]);

            const currentSecretDisplay = useMemo(() => {
                if (phase !== 'play') return "";
                let secret = turn === 1 ? p2Secret : p1Secret;
                if (displayMode === 'random') {
                    return secret.split('').sort(() => 0.5 - Math.random()).join('');
                }
                return secret;
            }, [phase, turn, p1Secret, p2Secret, displayMode]);

            const addPair = () => {
                const newId = pairs.length > 0 ? Math.max(...pairs.map(p => p.id)) + 1 : 1;
                setPairs([...pairs, { id: newId, a: "", b: "" }]);
            };

            const updatePair = (id, field, value) => {
                setPairs(pairs.map(p => p.id === id ? { ...p, [field]: value } : p));
            };

            const removePair = (id) => {
                setPairs(pairs.filter(p => p.id !== id));
            };

            const handleJsonImport = () => {
                try {
                    const data = JSON.parse(jsonInput);
                    if (data.pairs && Array.isArray(data.pairs)) {
                        const sanitizedPairs = data.pairs.map((p, idx) => ({
                            id: idx + 1,
                            a: p.a || "",
                            b: p.b || ""
                        }));
                        setPairs(sanitizedPairs);
                        setShowJsonModal(false);
                        setJsonInput(""); 
                    } else {
                        alert("Ungültiges JSON-Format.");
                    }
                } catch (e) {
                    alert("Fehler beim Parsen des JSON.");
                }
            };

            const getJsonExport = () => {
                return JSON.stringify({ pairs }, null, 2);
            };

            const initGame = () => {
                setPhase('mode-select');
                setP1Secret(""); setP1Confirm("");
                setP2Secret(""); setP2Confirm("");
                setWinner(null);
                setScores({1: 0, 2: 0});
                setWinReason("");
                setWaitingForTurnEnd(false);
                if (guessTimerRef.current) clearTimeout(guessTimerRef.current);
            };

            const selectMode = (mode) => {
                setDisplayMode(mode);
                setPhase('setup1');
            };

            const confirmSetup1 = () => {
                if (!p1Secret.trim() || p1Secret !== p1Confirm) return alert("Eingabe prüfen.");
                setPhase('setup2');
            };

            const confirmSetup2 = () => {
                if (!p2Secret.trim() || p2Secret !== p2Confirm) return alert("Eingabe prüfen.");
                startGameLoop();
            };

            const startGameLoop = () => {
                let deck = [];
                pairs.forEach(pair => {
                    deck.push({ id: `a-${pair.id}`, pairId: pair.id, content: pair.a, type: 'a' });
                    deck.push({ id: `b-${pair.id}`, pairId: pair.id, content: pair.b, type: 'b' });
                });
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                setCards(deck);
                setFlippedIndices([]);
                setMatchedIndices([]);
                setScores({ 1: 0, 2: 0 });
                setTurn(1);
                setCanGuess(false);
                setWaitingForTurnEnd(false);
                setGameMessage("Spieler 1 ist am Zug");
                setShowGuessInput(false);
                setPhase('play');
            };

            const checkEndGameByScore = (finalScores) => {
                if (finalScores[1] > finalScores[2]) {
                    setWinner(1); setWinReason("Alle Karten aufgedeckt. Spieler 1 gewinnt nach Punkten!");
                } else if (finalScores[2] > finalScores[1]) {
                    setWinner(2); setWinReason("Alle Karten aufgedeckt. Spieler 2 gewinnt nach Punkten!");
                } else {
                    setWinner('draw'); setWinReason("Alle Karten aufgedeckt. Unentschieden!");
                }
                setPhase('win');
            };

            const handleCardClick = (index) => {
                if (waitingForTurnEnd) return; 

                if (canGuess) {
                    setCanGuess(false);
                    if (guessTimerRef.current) clearTimeout(guessTimerRef.current);
                    if (matchedIndices.length === cards.length) { checkEndGameByScore(scores); return; }
                    setGameMessage(`Ratechance verpasst. Weiter geht's.`);
                }
                if (matchedIndices.includes(index) || flippedIndices.length >= 2 || flippedIndices.includes(index)) return;

                const newFlipped = [...flippedIndices, index];
                setFlippedIndices(newFlipped);

                if (newFlipped.length === 2) {
                    const card1 = cards[newFlipped[0]];
                    const card2 = cards[newFlipped[1]];
                    if (card1.pairId === card2.pairId) {
                        // MATCH
                        setTimeout(() => {
                            const newMatched = [...matchedIndices, newFlipped[0], newFlipped[1]];
                            setMatchedIndices(newMatched);
                            setFlippedIndices([]);
                            const newScores = { ...scores, [turn]: scores[turn] + 1 };
                            setScores(newScores);
                            setCanGuess(true); 
                            setGameMessage(`Treffer! 3 Sekunden Zeit zum Raten...`);
                            if (guessTimerRef.current) clearTimeout(guessTimerRef.current);
                            guessTimerRef.current = setTimeout(() => {
                                setCanGuess(false);
                                if (newMatched.length === cards.length) { checkEndGameByScore(newScores); }
                                else { setGameMessage(`Zeit abgelaufen! Spieler ${turn} ist weiter dran.`); }
                            }, 3000);
                        }, 1000);
                    } else {
                        // NO MATCH - NEU: Kein Timeout, sondern Warten auf User
                        setWaitingForTurnEnd(true);
                        setGameMessage("Leider falsch.");
                    }
                }
            };

            // NEU: Funktion zum manuellen Beenden des Zuges
            const finishTurn = () => {
                setFlippedIndices([]);
                const nextTurn = turn === 1 ? 2 : 1;
                setTurn(nextTurn);
                setWaitingForTurnEnd(false);
                setCanGuess(false); 
                setGameMessage(`Spieler ${nextTurn} ist am Zug`);
            };

            const handleOpenGuessModal = () => {
                if (guessTimerRef.current) clearTimeout(guessTimerRef.current);
                setShowGuessInput(true);
            };

            const handleGuessSubmit = () => {
                const targetSecret = turn === 1 ? p2Secret : p1Secret;
                if (guessAttempt.trim() === targetSecret.trim()) {
                    setWinner(turn);
                    setWinReason(`Spieler ${turn} hat das Lösungswort erraten!`);
                    setPhase('win');
                } else {
                    alert("Das war leider falsch! (Achte auf Groß-/Kleinschreibung) Der Zug wechselt.");
                    setGuessAttempt("");
                    setShowGuessInput(false);
                    setCanGuess(false);
                    if (matchedIndices.length === cards.length) { checkEndGameByScore(scores); }
                    else {
                        setTurn(turn === 1 ? 2 : 1);
                        setGameMessage(`Falsch geraten! Spieler ${turn === 1 ? 2 : 1} ist dran.`);
                    }
                }
            };

            const downloadStandalone = () => {
                const endScript = "</" + "script>";
                const head = `<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Duell</title>
    <script>
    window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']] }, svg: { fontCache: 'global' } };
    ${endScript}
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">${endScript}
    <style>
        * { box-sizing: border-box; }
        body { font-family: system-ui, -apple-system, sans-serif; background: #f1f5f9; margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; color: #0f172a; }
        .screen { display: none; flex-direction: column; justify-content: center; align-items: center; height: 100%; padding: 20px; text-align: center; }
        .screen.active { display: flex; }
        h1 { color: #4338ca; font-size: 1.5rem; font-weight: 800; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 8px; }
        .mode-btn { width: 100%; max-width: 400px; padding: 1rem; margin: 0.5rem; border: 2px solid #e2e8f0; background: white; border-radius: 0.75rem; cursor: pointer; text-align: left; transition: all 0.2s; display: flex; align-items: center; gap: 1rem; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .mode-btn:hover { border-color: #4f46e5; background: #eff6ff; }
        .mode-icon { background: #e0e7ff; color: #4f46e5; padding: 0.75rem; border-radius: 9999px; }
        .mode-title { font-weight: 700; color: #1e293b; font-size: 1rem; }
        .mode-desc { font-size: 0.75rem; color: #64748b; }
        .input-group { margin: 1.5rem 0; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 1rem; }
        input[type="password"] { font-size: 1.25rem; padding: 1rem; border-radius: 0.5rem; border: 2px solid #c7d2fe; text-align: center; width: 100%; box-sizing: border-box; outline: none; transition: border-color 0.2s; }
        input[type="password"]:focus { border-color: #4f46e5; }
        .action-btn { font-size: 1.125rem; padding: 0.75rem 2rem; background: #4f46e5; color: white; border: none; border-radius: 9999px; cursor: pointer; transition: 0.2s; font-weight: 700; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); display: flex; align-items: center; gap: 0.5rem; margin-top: 1rem; }
        .action-btn:hover { background: #4338ca; }
        .action-btn:disabled { background: #cbd5e1; cursor: not-allowed; opacity: 0.6; }
        #game-interface { display: none; flex-direction: column; height: 100%; padding: 1rem; box-sizing: border-box; max-width: 1200px; margin: 0 auto; width: 100%; }
        #game-interface.active { display: flex; }
        .header { flex: 0 0 auto; display: flex; justify-content: space-between; align-items: center; background: white; padding: 1rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1); border-radius: 0.75rem; margin-bottom: 1rem; z-index: 50; }
        .player-wrapper { display: flex; flex-direction: column; align-items: center; gap: 5px; min-width: 100px; }
        .score-box { text-align: center; padding: 0.25rem 1rem; border-radius: 0.5rem; border: 2px solid transparent; transition: all 0.3s; width: 100%; box-sizing: border-box; }
        .score-box > div:first-child { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; }
        .score-box > div:last-child { font-size: 1.5rem; font-weight: 700; }
        .p1-active .score-box { border-color: #3b82f6; background: #eff6ff; }
        .p1-active .score-box > div:first-child { color: #1e40af; }
        .p1-active .score-box > div:last-child { color: #2563eb; }
        .p2-active .score-box { border-color: #ec4899; background: #fdf2f8; }
        .p2-active .score-box > div:first-child { color: #9d174d; }
        .p2-active .score-box > div:last-child { color: #db2777; }
        .center-controls { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; flex: 1; }
        .game-msg { font-size: 0.875rem; font-weight: 500; color: #64748b; }
        .guess-btn { background: #f59e0b; font-size: 0.875rem; padding: 0.375rem 1rem; display: flex; align-items: center; gap: 0.5rem; transition: all 0.3s ease; border-radius: 9999px; border: none; cursor: pointer; color: white; font-weight: 700; box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05); }
        .guess-btn.active { background: #d97706; transform: scale(1.05); box-shadow: 0 0 0 4px #fde68a; animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        .guess-btn:disabled { background: #e2e8f0; color: #94a3b8; cursor: not-allowed; box-shadow: none; animation: none; }
        .cover-btn { background: #64748b; font-size: 0.75rem; padding: 0.25rem 0.75rem; border-radius: 9999px; border: none; cursor: pointer; color: white; font-weight: 700; visibility: hidden; margin-top: 2px; width: 100%; white-space: nowrap; }
        .cover-btn:hover { background: #475569; }
        @keyframes pulse { 50% { opacity: .5; } }
        .game-container { flex: 1; position: relative; border: 4px solid #1e293b; border-radius: 0.75rem; background: white; overflow: hidden; display: flex; justify-content: center; align-items: center; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06); }
        .message-layer { position: absolute; inset: 0; z-index: 10; pointer-events: none; opacity: 0; display: flex; transition: opacity 0.3s ease; }
        .card-grid { position: relative; z-index: 20; display: grid; gap: 0; width: 100%; height: 100%; padding: 0; box-sizing: border-box; }
        .card { cursor: pointer; padding: 0; border: none; outline: none; perspective: 1000px; display: block; position: relative; background: transparent; user-select: none; border: 1px solid rgba(255,255,255,0.8); }
        .card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; }
        .card.flipped .card-inner { transform: rotateY(180deg); }
        .card.flipped { z-index: 50; }
        .face { position: absolute; top: 0; left: 0; width: 100%; height: 100%; backface-visibility: hidden; -webkit-backface-visibility: hidden; display: flex; justify-content: center; align-items: center; }
        .face.back { background: #4f46e5; color: rgba(255,255,255,0.5); font-size: 2rem; font-weight: 700; }
        .face.front { background: white; border: 2px solid #4f46e5; color: #312e81; font-weight: 600; transform: rotateY(180deg); overflow: hidden; padding: 4px; font-size: clamp(0.75rem, 2.5vw, 1.25rem); }
        .content-wrap { width: 100%; max-width: 100%; text-align: center; word-break: break-word; overflow-wrap: break-word; hyphens: auto; }
        mjx-container { font-size: inherit !important; outline: 0 !important; }
        .card.matched { opacity: 0; pointer-events: none; visibility: hidden; }
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; justify-content: center; align-items: center; backdrop-filter: blur(4px); }
        .modal.active { display: flex; animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background: white; padding: 2rem; border-radius: 1rem; text-align: center; width: 90%; max-width: 400px; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1); }
        #timer-bar { position: absolute; bottom: -8px; left: 0; height: 4px; background: #f59e0b; width: 0%; border-radius: 9999px; }
        .icon { width: 20px; height: 20px; display: inline-block; stroke: currentColor; fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
    </style>
</head>
<body>
    <div id="screen-mode" class="screen active"><h1>Spielmodus wählen</h1><button class="mode-btn" onclick="selectMode('normal')"><div class="mode-icon"><svg class="icon" viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" x2="15" y1="20" y2="20"/><line x1="12" x2="12" y1="4" y2="20"/></svg></div><div><div class="mode-title">Normal</div><div class="mode-desc">Text normal lesbar</div></div></button><button class="mode-btn" onclick="selectMode('flipped')"><div class="mode-icon"><svg class="icon" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3"/><path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/><path d="M12 3v18"/></svg></div><div><div class="mode-title">Spiegelverkehrt</div><div class="mode-desc">Text ist gespiegelt</div></div></button><button class="mode-btn" onclick="selectMode('random')"><div class="mode-icon"><svg class="icon" viewBox="0 0 24 24"><path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l14.2-13h3.1"/><path d="M2 5h1.6c1.3 0 2.5.6 3.3 1.7l1.6 1.5"/><path d="M12 15.5l2.7 2.5c.8 1.1 2 1.7 3.3 1.7h3.1"/></svg></div><div><div class="mode-title">Buchstabensalat</div><div class="mode-desc">Buchstaben durcheinander</div></div></button></div>
    <div id="screen-setup1" class="screen"><h1>Spieler 1 - Setup</h1><p class="game-msg">Geheime Nachricht für Spieler 2 eingeben.</p><div class="input-group"><input type="password" id="inputP1" placeholder="Geheime Nachricht"><input type="password" id="inputP1Conf" placeholder="Bestätigung"></div><button class="action-btn" onclick="confirmP1()">Weiter <svg class="icon" viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg></button></div>
    <div id="screen-setup2" class="screen"><h1>Spieler 2 - Setup</h1><p class="game-msg">Geheime Nachricht für Spieler 1 eingeben.</p><div class="input-group"><input type="password" id="inputP2" placeholder="Geheime Nachricht"><input type="password" id="inputP2Conf" placeholder="Bestätigung"></div><button class="action-btn" onclick="startGame()">Start <svg class="icon" viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg></button></div>
    <div id="game-interface"><div class="header">
        <div id="p1-wrapper" class="player-wrapper"><div class="score-box"><div>Spieler 1</div><div id="score1">0</div></div><button id="coverBtn1" class="cover-btn" onclick="finishTurn()">Weiter</button></div>
        <div class="center-controls"><div id="game-message" class="game-msg">Spieler 1 ist am Zug</div><div style="position: relative;"><button id="guessBtn" class="guess-btn" onclick="openGuessModal()" disabled><span id="lockIcon"><svg class="icon" viewBox="0 0 24 24"><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg></span><span>Lösung raten?</span></button><div id="timer-bar"></div></div></div>
        <div id="p2-wrapper" class="player-wrapper"><div class="score-box"><div>Spieler 2</div><div id="score2">0</div></div><button id="coverBtn2" class="cover-btn" onclick="finishTurn()">Weiter</button></div>
    </div><div class="game-container"><div id="bg-message" class="message-layer"></div><div id="grid" class="card-grid"></div></div></div>
    <div id="guessModal" class="modal"><div class="modal-content"><h2 id="guessTitle" style="font-size:1.25rem; font-weight:700; margin-bottom:0.5rem; color:#1e293b;">Spieler X rät</h2><p style="color:#64748b; font-size:0.875rem; margin-bottom:1rem;">Welche Nachricht versteckt sich hinter den Karten?</p><input type="text" id="guessInput" style="font-size: 1.25rem; padding: 0.75rem; border-radius: 0.5rem; border: 2px solid #cbd5e1; text-align: center; width: 100%; box-sizing: border-box; margin-bottom:1.5rem; outline:none; text-transform:uppercase; font-weight:700;"><div style="display:flex; gap:10px; justify-content:center;"><button class="action-btn" style="margin:0; background:#64748b; padding:0.5rem 1.5rem; font-size:1rem;" onclick="closeGuessModal()">Abbrechen</button><button class="action-btn" style="margin:0; background:#16a34a; padding:0.5rem 1.5rem; font-size:1rem;" onclick="submitGuess()">Prüfen</button></div></div></div>
    <div id="winModal" class="modal"><div class="modal-content"><svg class="icon" viewBox="0 0 24 24" style="width:80px; height:80px; color:#f59e0b; margin-bottom:1rem;"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg><h1 id="winTitle" style="color:#1e293b; font-size:2rem; margin-bottom:0.5rem;">GEWONNEN!</h1><p id="winText" style="color:#64748b; margin-bottom:2rem; font-size:1.2rem;"></p><button class="action-btn" onclick="location.reload()" style="background:#4f46e5; margin:0 auto;">Nochmal spielen</button></div></div>
`;
                const scriptContent = `
        const config = ${JSON.stringify({ pairs: pairs })};
        let p1Secret="", p2Secret="", displayMode="normal", cards=[], flipped=[], matched=[], turn=1, scores={1:0,2:0}, lockBoard=false, canGuess=false, guessTimer=null, waitingForTurnEnd=false;
        function selectMode(m) { displayMode=m; document.getElementById('screen-mode').classList.remove('active'); document.getElementById('screen-setup1').classList.add('active'); }
        function confirmP1() { const val=document.getElementById('inputP1').value.trim(), conf=document.getElementById('inputP1Conf').value.trim(); if(!val || val!==conf) return alert("Fehlerhafte Eingabe"); p1Secret=val; document.getElementById('screen-setup1').classList.remove('active'); document.getElementById('screen-setup2').classList.add('active'); }
        function startGame() { const val=document.getElementById('inputP2').value.trim(), conf=document.getElementById('inputP2Conf').value.trim(); if(!val || val!==conf) return alert("Fehlerhafte Eingabe"); p2Secret=val; document.getElementById('screen-setup2').classList.remove('active'); document.getElementById('game-interface').classList.add('active'); initBoard(); updateTurnUI(); }
        function initBoard() {
            let deck=[]; config.pairs.forEach(p=>{ deck.push({id:'a-'+p.id, pid:p.id, html:p.a}); deck.push({id:'b-'+p.id, pid:p.id, html:p.b}); });
            for(let i=deck.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }
            const grid=document.getElementById('grid'), count=deck.length, cols=Math.ceil(Math.sqrt(count)), rows=Math.ceil(count/cols);
            grid.style.gridTemplateColumns=\`repeat(\${cols},1fr)\`; grid.style.gridTemplateRows=\`repeat(\${rows},1fr)\`;
            deck.forEach((card,index)=>{ const el=document.createElement('div'); el.className='card'; el.innerHTML=\`<div class="card-inner"><div class="face back">?</div><div class="face front"><div class="content-wrap">\${card.html}</div></div></div>\`; el.onclick=()=>handleCardClick(index); grid.appendChild(el); cards.push({...card,el}); });
            if (window.MathJax) { setTimeout(() => window.MathJax.typesetPromise(), 100); }
        }
        function getDisplaySecret(text) { return displayMode==='random'?text.split('').sort(()=>0.5-Math.random()).join(''):text; }
        function updateMessage(text) {
            const msgEl=document.getElementById('bg-message'), displayText=getDisplaySecret(text), scaleX=displayMode==='flipped'?'-1':'1';
            msgEl.innerHTML=\`<svg width="100%" height="100%" viewBox="0 0 100 20" preserveAspectRatio="none"><text x="50" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-weight="900" font-size="18" fill="#166534" textLength="100" lengthAdjust="spacingAndGlyphs" transform="scale(\${scaleX}, 1)" transform-origin="center">\${displayText}</text></svg>\`;
        }
        function handleCardClick(index) {
            if(waitingForTurnEnd) return;
            if(canGuess) { setCanGuess(false); document.getElementById('game-message').innerText="Ratechance verpasst. Weiter geht's."; if(matched.length===cards.length){checkWinByScore(); return;} }
            if(lockBoard || matched.includes(index) || flipped.includes(index)) return;
            const card=cards[index]; card.el.classList.add('flipped'); flipped.push(index); if(flipped.length===2) checkMatch();
        }
        function setCanGuess(val) {
            canGuess=val; const btn=document.getElementById('guessBtn'), msgEl=document.getElementById('bg-message'), bar=document.getElementById('timer-bar');
            btn.disabled=!val; const lockSvg='<svg class="icon" viewBox="0 0 24 24"><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>', eyeSvg='<svg class="icon" viewBox="0 0 24 24"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>';
            document.getElementById('lockIcon').innerHTML=val?eyeSvg:lockSvg; if(val)btn.classList.add('active');else btn.classList.remove('active'); msgEl.style.opacity=val?'1':'0';
            if(val) { bar.style.transition='none'; bar.style.width='100%'; setTimeout(()=>{bar.style.transition='width 3s linear';bar.style.width='0%';},50); if(guessTimer)clearTimeout(guessTimer); guessTimer=setTimeout(()=>{setCanGuess(false); if(matched.length===cards.length)checkWinByScore(); else document.getElementById('game-message').innerText='Zeit abgelaufen! Spieler '+turn+' ist weiter dran.';},3000); }
            else { if(guessTimer)clearTimeout(guessTimer); bar.style.width='0%'; bar.style.transition='none'; }
        }
        function checkMatch() {
            lockBoard=true; const c1=cards[flipped[0]], c2=cards[flipped[1]];
            if(c1.pid===c2.pid) { setTimeout(()=>{cards[flipped[0]].el.classList.add('matched'); cards[flipped[1]].el.classList.add('matched'); matched.push(...flipped); flipped=[]; scores[turn]++; const b1=document.getElementById('p1-wrapper'), b2=document.getElementById('p2-wrapper'); document.getElementById('score1').innerText=scores[1]; document.getElementById('score2').innerText=scores[2]; let s=turn===1?p2Secret:p1Secret; updateMessage(s); document.getElementById('game-message').innerText="Treffer! 3 Sekunden Zeit zum Raten..."; setCanGuess(true); lockBoard=false;},1000); }
            else { 
                waitingForTurnEnd = true;
                const btn = turn === 1 ? document.getElementById('coverBtn1') : document.getElementById('coverBtn2');
                btn.style.visibility = 'visible';
                document.getElementById('game-message').innerText = "Leider falsch.";
            }
        }
        function finishTurn() {
            cards[flipped[0]].el.classList.remove('flipped'); cards[flipped[1]].el.classList.remove('flipped'); flipped=[]; 
            const btn = turn === 1 ? document.getElementById('coverBtn1') : document.getElementById('coverBtn2');
            btn.style.visibility = 'hidden';
            turn=turn===1?2:1; 
            waitingForTurnEnd = false;
            setCanGuess(false); updateTurnUI(); document.getElementById('game-message').innerText="Spieler "+turn+" ist am Zug."; lockBoard=false;
        }
        function updateTurnUI() {
            document.getElementById('score1').innerText=scores[1]; document.getElementById('score2').innerText=scores[2];
            const b1=document.getElementById('p1-wrapper'), b2=document.getElementById('p2-wrapper'); let s=turn===1?p2Secret:p1Secret;
            if(turn===1){b1.classList.add('p1-active');b2.classList.remove('p2-active');}else{b1.classList.remove('p1-active');b2.classList.add('p2-active');} updateMessage(s);
        }
        function checkWinByScore() {
            let t="ENDE",txt=""; if(scores[1]>scores[2])txt="Spieler 1 gewinnt!";else if(scores[2]>scores[1])txt="Spieler 2 gewinnt!";else{t="UNENTSCHIEDEN";txt="Gleicher Punktestand.";}
            document.getElementById('winTitle').innerText=t; document.getElementById('winText').innerText=txt; document.getElementById('winModal').classList.add('active');
        }
        function openGuessModal() { setCanGuess(false); document.getElementById('guessTitle').innerText='Spieler '+turn+' rät'; document.getElementById('guessInput').value=''; document.getElementById('guessModal').classList.add('active'); }
        function closeGuessModal() { document.getElementById('guessModal').classList.remove('active'); if(matched.length===cards.length)checkWinByScore(); }
        function submitGuess() {
            const g=document.getElementById('guessInput').value.trim(), t=(turn===1?p2Secret:p1Secret).trim();
            if(g===t) { closeGuessModal(); document.getElementById('winTitle').innerText='GEWONNEN!'; document.getElementById('winText').innerText='Spieler '+turn+' hat es erraten!'; document.getElementById('winModal').classList.add('active'); }
            else { alert('Falsch! (Case-sensitive) Zugwechsel.'); closeGuessModal(); if(matched.length===cards.length){checkWinByScore();}else{turn=turn===1?2:1; updateTurnUI(); document.getElementById('game-message').innerText="Falsch geraten! Spieler "+turn+" ist dran.";} }
        }
    `;
                const finalHtml = head + "<script>" + scriptContent + endScript + "</body></html>";
                const blob = new Blob([finalHtml], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'LernMemory_Duell.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // --- RENDER ---
            return (
                <div className="min-h-screen flex flex-col p-4 max-w-6xl mx-auto w-full">
                    {/* Header */}
                    <header className="flex justify-between items-center mb-4 bg-white p-4 rounded-xl shadow-sm">
                        <h1 className="text-xl font-bold flex items-center gap-2 text-indigo-600">
                            <Icons.Settings /> Didaktisches Memory: Duell
                        </h1>
                        <div className="flex gap-2">
                            {phase !== 'editor' && (
                                <button onClick={() => setPhase('editor')} className="px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded-lg font-medium text-sm transition">Editor</button>
                            )}
                            {phase === 'editor' && (
                                <button onClick={initGame} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-medium text-sm flex items-center gap-2 transition">
                                    <Icons.Play /> Spiel testen
                                </button>
                            )}
                        </div>
                    </header>

                    {/* EDITOR */}
                    {phase === 'editor' && (
                        <div className="space-y-6 flex-1 overflow-y-auto">
                            <div className="bg-blue-50 border border-blue-200 p-4 rounded-lg text-blue-800 text-sm">
                                <strong>Info:</strong> Geheimwörter & Modus werden beim Spielstart gewählt. HTML Tags wie &lt;b&gt;bold&lt;/b&gt; sind erlaubt.
                            </div>
                            <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-100">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-lg font-semibold text-slate-800">Kartenpaare ({pairs.length})</h2>
                                    <button onClick={() => { setJsonInput(getJsonExport()); setShowJsonModal(true); }} className="text-xs flex items-center gap-2 px-3 py-2 bg-slate-100 hover:bg-slate-200 rounded text-slate-700 border border-slate-300 shadow-sm transition">
                                        <Icons.FileJson size={16}/> JSON
                                    </button>
                                </div>
                                <div className="space-y-3">
                                    {pairs.map((pair, idx) => (
                                        <div key={pair.id} className="flex flex-col md:flex-row gap-2 items-start md:items-center bg-slate-50 p-3 rounded-lg border border-slate-200">
                                            <div className="bg-indigo-100 text-indigo-700 w-8 h-8 flex items-center justify-center rounded-full font-bold text-sm shrink-0">{idx + 1}</div>
                                            <input className="flex-1 p-2 border border-slate-300 rounded text-sm w-full" placeholder="Karte 1" value={pair.a} onChange={(e) => updatePair(pair.id, 'a', e.target.value)} />
                                            <span className="text-slate-400 font-bold">=</span>
                                            <input className="flex-1 p-2 border border-slate-300 rounded text-sm w-full" placeholder="Karte 2" value={pair.b} onChange={(e) => updatePair(pair.id, 'b', e.target.value)} />
                                            <button onClick={() => removePair(pair.id)} className="p-2 text-red-400 hover:text-red-600 hover:bg-red-50 rounded transition shrink-0"><Icons.Trash2 size={18} /></button>
                                        </div>
                                    ))}
                                </div>
                                <button onClick={addPair} className="mt-4 w-full py-3 border-2 border-dashed border-slate-300 text-slate-500 rounded-lg hover:border-indigo-500 hover:text-indigo-500 transition flex justify-center items-center gap-2"><Icons.Plus size={20} /> Neues Pärchen</button>
                            </div>
                            <div className="bg-indigo-50 p-6 rounded-xl border border-indigo-100 flex flex-col md:flex-row justify-between items-center gap-4">
                                <div><h3 className="font-bold text-indigo-900">Exportieren</h3><p className="text-sm text-indigo-700">Offline-fähige HTML-Datei herunterladen.</p></div>
                                <button onClick={downloadStandalone} className="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg shadow-md flex items-center gap-2 font-bold transition whitespace-nowrap"><Icons.Download size={20} /> Als HTML speichern</button>
                            </div>
                        </div>
                    )}

                    {/* PHASES: MODE / SETUP / WIN / PLAY */}
                    {phase === 'mode-select' && (
                        <div className="flex flex-col items-center justify-center min-h-[50vh] p-8 bg-white rounded-xl shadow-lg max-w-lg mx-auto mt-10 animate-bounce-in">
                            <h2 className="text-2xl font-bold mb-4 text-indigo-700">Spielmodus wählen</h2>
                            <div className="grid gap-4 w-full">
                                <button onClick={() => selectMode('normal')} className="flex items-center gap-4 p-4 border border-indigo-100 hover:border-indigo-500 rounded-xl hover:bg-indigo-50 transition group text-left"><div className="bg-indigo-100 p-3 rounded-full text-indigo-600"><Icons.Type /></div><div><div className="font-bold">Normal</div><div className="text-xs text-slate-500">Standardanzeige</div></div></button>
                                <button onClick={() => selectMode('flipped')} className="flex items-center gap-4 p-4 border border-indigo-100 hover:border-indigo-500 rounded-xl hover:bg-indigo-50 transition group text-left"><div className="bg-indigo-100 p-3 rounded-full text-indigo-600"><Icons.FlipHorizontal /></div><div><div className="font-bold">Spiegelverkehrt</div><div className="text-xs text-slate-500">Text gespiegelt</div></div></button>
                                <button onClick={() => selectMode('random')} className="flex items-center gap-4 p-4 border border-indigo-100 hover:border-indigo-500 rounded-xl hover:bg-indigo-50 transition group text-left"><div className="bg-indigo-100 p-3 rounded-full text-indigo-600"><Icons.Shuffle /></div><div><div className="font-bold">Buchstabensalat</div><div className="text-xs text-slate-500">Wild gemischt</div></div></button>
                            </div>
                        </div>
                    )}

                    {(phase === 'setup1' || phase === 'setup2') && (
                        <div className="flex flex-col items-center justify-center min-h-[50vh] p-8 bg-white rounded-xl shadow-lg max-w-lg mx-auto mt-10">
                            <h2 className="text-2xl font-bold mb-4 text-indigo-700">{phase === 'setup1' ? 'Spieler 1' : 'Spieler 2'} - Setup</h2>
                            <p className="mb-4 text-slate-600">Geheime Nachricht für {phase === 'setup1' ? 'Spieler 2' : 'Spieler 1'} eingeben.</p>
                            <div className="w-full flex flex-col gap-4 mb-6">
                                <input type="password" className="w-full p-4 text-center text-xl border-2 border-indigo-200 rounded-lg focus:border-indigo-500 outline-none" placeholder="Geheimwort" value={phase === 'setup1' ? p1Secret : p2Secret} onChange={(e) => phase === 'setup1' ? setP1Secret(e.target.value) : setP2Secret(e.target.value)} />
                                <input type="password" className="w-full p-4 text-center text-xl border-2 border-indigo-200 rounded-lg focus:border-indigo-500 outline-none" placeholder="Bestätigung" value={phase === 'setup1' ? p1Confirm : p2Confirm} onChange={(e) => phase === 'setup1' ? setP1Confirm(e.target.value) : setP2Confirm(e.target.value)} />
                            </div>
                            <button onClick={phase === 'setup1' ? confirmSetup1 : confirmSetup2} className="px-8 py-3 bg-indigo-600 text-white rounded-full font-bold text-lg hover:bg-indigo-700 transition shadow-md flex items-center gap-2">Weiter <Icons.Play size={20} /></button>
                        </div>
                    )}

                    {phase === 'win' && (
                        <div className="flex flex-col items-center justify-center h-full animate-bounce-in">
                            <Icons.Trophy size={80} className="text-yellow-500 mb-4" />
                            <h1 className="text-4xl font-black text-slate-800 mb-2">{winner === 'draw' ? 'UNENTSCHIEDEN' : 'GEWONNEN!'}</h1>
                            <p className="text-xl text-slate-600 mb-8">{winReason}</p>
                            <button onClick={initGame} className="px-6 py-3 bg-indigo-600 text-white rounded-lg">Nochmal spielen</button>
                        </div>
                    )}

                    {phase === 'play' && (
                        <div className="flex flex-col h-full overflow-hidden flex-1">
                            <div className="flex justify-between items-center bg-white p-4 rounded-xl shadow-sm mb-4 shrink-0 z-20">
                                <div className={`flex flex-col items-center px-4 py-1 rounded-lg border-2 transition-all ${turn === 1 ? 'bg-blue-50 border-blue-500 scale-105' : 'border-transparent opacity-60'}`}>
                                    <span className="text-xs font-bold uppercase text-blue-800">Spieler 1</span>
                                    <span className="text-2xl font-bold text-blue-600">{scores[1]}</span>
                                    <button 
                                        onClick={finishTurn} 
                                        className={`mt-2 px-3 py-1 bg-slate-600 hover:bg-slate-700 text-white font-bold rounded-full text-xs shadow-md transition-all animate-bounce-in whitespace-nowrap ${waitingForTurnEnd && turn === 1 ? 'visible' : 'invisible'}`}
                                    >
                                        Weiter
                                    </button>
                                </div>
                                <div className="flex flex-col items-center gap-2 flex-1">
                                    <div className="text-xs md:text-sm font-medium text-slate-500 text-center">{gameMessage}</div>
                                    <div className="relative">
                                        <button onClick={handleOpenGuessModal} disabled={!canGuess} className={`px-4 py-1.5 text-sm font-bold rounded-full shadow-sm transition flex items-center gap-2 ${canGuess ? 'bg-amber-500 hover:bg-amber-600 text-white cursor-pointer ring-4 ring-amber-200 animate-pulse' : 'bg-slate-200 text-slate-400 cursor-not-allowed'}`}>
                                            {canGuess ? <Icons.Eye size={16}/> : <Icons.Lock size={16}/>} Raten?
                                        </button>
                                        {canGuess && <div className="absolute -bottom-2 left-0 h-1 bg-amber-500 rounded-full w-full animate-[width_3s_linear_forwards]" style={{animationName: 'shrinkWidth', width: '100%'}}></div>}
                                        <style>{`@keyframes shrinkWidth { from { width: 100%; } to { width: 0%; } }`}</style>
                                    </div>
                                </div>
                                <div className={`flex flex-col items-center px-4 py-1 rounded-lg border-2 transition-all ${turn === 2 ? 'bg-pink-50 border-pink-500 scale-105' : 'border-transparent opacity-60'}`}>
                                    <span className="text-xs font-bold uppercase text-pink-800">Spieler 2</span>
                                    <span className="text-2xl font-bold text-pink-600">{scores[2]}</span>
                                    <button 
                                        onClick={finishTurn} 
                                        className={`mt-2 px-3 py-1 bg-slate-600 hover:bg-slate-700 text-white font-bold rounded-full text-xs shadow-md transition-all animate-bounce-in whitespace-nowrap ${waitingForTurnEnd && turn === 2 ? 'visible' : 'invisible'}`}
                                    >
                                        Weiter
                                    </button>
                                </div>
                            </div>

                            {showGuessInput && (
                                <div className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4">
                                    <div className="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full animate-bounce-in">
                                        <h3 className="text-lg font-bold mb-2">Lösung raten</h3>
                                        <input autoFocus className="w-full p-3 border border-slate-300 rounded mb-4 text-center font-bold uppercase" value={guessAttempt} onChange={(e) => setGuessAttempt(e.target.value)} placeholder="Dein Tipp..." />
                                        <div className="flex justify-end gap-2">
                                            <button onClick={() => setShowGuessInput(false)} className="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded">Abbrechen</button>
                                            <button onClick={handleGuessSubmit} className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded font-bold">Prüfen</button>
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="relative flex-grow min-h-[400px] w-full bg-white rounded-xl shadow-inner border-4 border-slate-800 overflow-hidden">
                                <div className="absolute inset-0 flex items-center justify-center p-0 z-10 select-none pointer-events-none transition-opacity duration-300" style={{ opacity: canGuess ? 1 : 0 }}>
                                    <svg width="100%" height="100%" viewBox="0 0 100 20" preserveAspectRatio="none">
                                        <text x="50" y="50%" dominantBaseline="middle" textAnchor="middle" fontFamily="sans-serif" fontWeight="900" fontSize="18" fill="#166534" textLength="100" lengthAdjust="spacingAndGlyphs" style={{ transformOrigin: "center", transform: displayMode === 'flipped' ? "scaleX(-1)" : "none" }}>{currentSecretDisplay}</text>
                                    </svg>
                                </div>
                                <div className="absolute inset-0 z-20 grid p-0" style={{ gap: '0px', gridTemplateColumns: `repeat(${Math.ceil(Math.sqrt(cards.length))}, 1fr)`, gridTemplateRows: `repeat(${Math.ceil(cards.length / Math.ceil(Math.sqrt(cards.length)))}, 1fr)` }}>
                                    {cards.map((card, idx) => {
                                        const isFlipped = flippedIndices.includes(idx);
                                        const isMatched = matchedIndices.includes(idx);
                                        if (isMatched) return <div key={idx} className="invisible"></div>;
                                        return (
                                            <button key={idx} onClick={() => handleCardClick(idx)} disabled={isFlipped || isMatched} style={{ perspective: '1000px', transformStyle: 'preserve-3d', zIndex: isFlipped ? 50 : 'auto' }} className="relative w-full h-full p-0 m-0 border border-white/80 outline-none">
                                                <div className="w-full h-full relative" style={{ transformStyle: 'preserve-3d', transition: 'transform 0.6s', transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)' }}>
                                                    <div className="absolute inset-0 bg-indigo-500 flex items-center justify-center backface-hidden" style={{ backfaceVisibility: 'hidden' }}><span className="text-white opacity-50 text-2xl md:text-4xl font-bold">?</span></div>
                                                    <div className="absolute inset-0 bg-white border-2 border-indigo-500 flex items-center justify-center backface-hidden overflow-hidden p-1" style={{ backfaceVisibility: 'hidden', transform: 'rotateY(180deg)' }}>
                                                        <span className="text-indigo-900 font-semibold text-xs sm:text-sm md:text-base lg:text-xl break-words text-center" dangerouslySetInnerHTML={{ __html: card.content }} />
                                                    </div>
                                                </div>
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {showJsonModal && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
                            <div className="bg-white rounded-xl p-6 w-full max-w-lg shadow-2xl">
                                <h3 className="text-lg font-bold mb-2">JSON Import</h3>
                                <textarea className="w-full h-48 p-3 border border-slate-300 rounded-lg font-mono text-xs mb-4 bg-slate-50" value={jsonInput} onChange={(e) => setJsonInput(e.target.value)} placeholder='{ "pairs": [...] }' />
                                <div className="flex justify-end gap-2"><button onClick={() => setShowJsonModal(false)} className="px-4 py-2 text-slate-600 rounded-lg">Abbrechen</button><button onClick={handleJsonImport} className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center gap-2"><Icons.Upload size={16}/> Import</button></div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MemoryBuilderApp />);
    </script>
</body>
</html>
